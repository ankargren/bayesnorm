#ifndef BAYESNORM_MVN_CBM_H
#define BAYESNORM_MVN_CBM_H
inline arma::vec mvn_cbm(const arma::mat & Phi, const arma::vec & d, 
                         const arma::vec & alpha, std::function<double()> rnorm = norm_rand) {
  arma::uword n = Phi.n_rows;
  arma::uword p = Phi.n_cols;
  
  arma::mat U = Phi.t();
  U.each_col() %= d;
  arma::vec d_sqrt = sqrt(d);
  arma::mat I(n, n, arma::fill::eye);
  arma::vec u(p);
  u.imbue(rnorm);
  arma::vec delta(n);
  delta.imbue(rnorm);
  u %= d_sqrt;
  arma::vec v = Phi * u + delta;
  arma::vec w = arma::solve(Phi * U + I, (alpha - v));
  arma::vec theta = u + U * w;
  
  return theta;
}

// [[Rcpp::export]]
std::vector<arma::mat> rnorm_posterior(const arma::mat & Phi, const arma::vec & d, 
                                       const arma::vec & alpha, unsigned int seed, unsigned int ncores = 1) {
  dqrng::normal_distribution dist(0.0, 1.0);
  dqrng::xoshiro256plus rng(seed);
  std::vector<arma::mat> res(ncores);
  
#pragma omp parallel num_threads(ncores)
{
  dqrng::xoshiro256plus lrng(rng);      // make thread local copy of rng 
  lrng.jump(omp_get_thread_num() + 1);  // advance rng by 1 ... ncores jumps 
  res[omp_get_thread_num()] = mvn_cbm(Phi, d, alpha, [&](){return dist(lrng);});
}
return res;
}

#endif